{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAAA,OAAO,SAAS,MAAM,YAAY,CAAA;AAClC,OAAO,EAAE,QAAQ,EAAE,MAAM,mBAAmB,CAAA;AAG5C,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAA;AAUvC,MAAM,UAAU,eAAe,CAAC,QAAgB;IAC5C,MAAM,OAAO,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAA;IAClC,OAAQ,EAAe;SAClB,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC;SAC9D,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAA;AACtD,CAAC;AASD,MAAM,UAAU,gBAAgB,CAAC,UAAiC;IAC9D,IAAI,UAAU,CAAC,KAAK,KAAK,MAAM,EAAE;QAC7B,OAAO;YACH,aAAa,EAAE,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC;SACnD,CAAA;KACJ;IAED,OAAO,EAAE,CAAA;AACb,CAAC;AAWD,MAAM,UAAU,aAAa,CAAC,KAAa,EAAE,QAAgB;IACzD,MAAM,YAAY,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAA;IAC9C,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAA;AACpE,CAAC;AAWD,MAAM,UAAU,iBAAiB,CAAC,KAAa,EAAE,QAAgB;IAC7D,MAAM,YAAY,GAAG,EAAE,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAA;IAC9E,MAAM,mBAAmB,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,OAAe,EAAE,EAAE,CAC7D,OAAO,CAAC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,CACjD,CAAA;IACD,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;IAClE,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,EAAE,CAAA;AAC1C,CAAC","sourcesContent":["import stripAnsi from 'strip-ansi'\nimport { dialects } from '@cucumber/gherkin'\nimport type { HookStats, TestStats } from '@wdio/reporter'\n\nimport { FAILED } from './constants.js'\nimport type { ErrorMessage, Step } from './types'\n\n/**\n * Return the list of step keywords in the specified language\n *\n * @param language {string}\n *\n * @return {string[]}\n */\nexport function getStepKeywords(language: string): string[] {\n    const dialect = dialects[language]\n    return ([] as string[])\n        .concat(dialect.given, dialect.when, dialect.then, dialect.and)\n        .map((keyword) => keyword.replace(/\\s*$/, ''))\n}\n\n/**\n * Add a failed message\n *\n * @param {object}  testObject\n *\n * @return {object}\n */\nexport function getFailedMessage(testObject: TestStats | HookStats): ErrorMessage {\n    if (testObject.state === FAILED) {\n        return {\n            error_message: stripAnsi(testObject.error.stack),\n        }\n    }\n\n    return {}\n}\n\n/**\n * Check if the steps contain valid steps\n *\n * @param {array} steps\n *\n * @param {string} language\n *\n * @return {boolean}\n */\nexport function containsSteps(steps: Step[], language: string): boolean {\n    const stepKeywords = getStepKeywords(language)\n    return steps.some((step) => stepKeywords.includes(step.keyword))\n}\n\n/**\n * Returns the first word in case it's a keyword in the specified language\n *\n * @param {array} title\n *\n * @param {string} language\n *\n * @return {string|undefined}\n */\nexport function keywordStartsWith(title: string, language: string): string | undefined {\n    const stepKeywords = [].concat(getStepKeywords(language), ['After', 'Before'])\n    const escapedStepKeywords = stepKeywords.map((keyword: string) =>\n        keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'),\n    )\n    const regex = new RegExp(`^(${escapedStepKeywords.join('|')})\\\\s`)\n    return (regex.exec(title) || []).pop()\n}\n"]}