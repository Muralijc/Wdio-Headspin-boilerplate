import fs from 'fs-extra';
import path from 'node:path';
import WDIOReporter from '@wdio/reporter';
import logger from '@wdio/logger';
import { AFTER, BEFORE, DEFAULT_JSON_FOLDER, DEFAULT_LANGUAGE, DEFAULT_REPORT_FILE_PER_RETRY, FEATURE, PASSED, SCENARIO, TEXT_PLAIN, } from './constants.js';
import { Metadata } from './metadata.js';
import { containsSteps, keywordStartsWith, getFailedMessage } from './utils.js';
const log = logger('wdio-cucumberjs-json-reporter');
export class CucumberJsJsonReporter extends WDIOReporter {
    constructor(options) {
        super(options);
        this.options = options;
        this.options = options;
        if (!this.options.jsonFolder) {
            this.options.jsonFolder = DEFAULT_JSON_FOLDER;
            log.info(`The 'jsonFolder' was not set, it has been set to the default '${DEFAULT_JSON_FOLDER}'`);
        }
        if (!this.options.language) {
            this.options.language = DEFAULT_LANGUAGE;
            log.info(`The 'language' was not set, it has been set to the default '${DEFAULT_LANGUAGE}'`);
        }
        if (this.options.reportFilePerRetry === undefined) {
            this.options.reportFilePerRetry = DEFAULT_REPORT_FILE_PER_RETRY;
            log.info(`The 'reportFilePerRetry' was not set, it has been set to the default '${DEFAULT_REPORT_FILE_PER_RETRY.toString()}'`);
        }
        this.instanceMetadata = null;
        this.report = {};
        this.registerListeners();
        this.metadataClassObject = new Metadata();
    }
    static attach(data, type = TEXT_PLAIN) {
        process.emit('wdioCucumberJsReporter:attachment', { data, type });
    }
    registerListeners() {
        process.on('wdioCucumberJsReporter:attachment', this.cucumberJsAttachment.bind(this));
    }
    onRunnerStart(runnerData) {
        if (!this.instanceMetadata) {
            this.instanceMetadata = this.metadataClassObject.determineMetadata(runnerData);
        }
    }
    onSuiteStart(payload) {
        if (!this.report.feature) {
            this.report.feature = this.getFeatureDataObject(payload);
        }
        if (!this.report.feature.metadata) {
            this.report.feature = { ...this.report.feature, metadata: { ...this.instanceMetadata } };
        }
        if (typeof this.report.feature.elements !== 'undefined' && payload.parent) {
            this.report.feature.elements.push(this.getScenarioDataObject(payload, this.report.feature.id));
        }
    }
    onHookStart(payload) {
        if (this.options.disableHooks) {
            return;
        }
        const currentSteps = this.getCurrentScenario().steps;
        payload.state = PASSED;
        payload.keyword = containsSteps(currentSteps, this.options.language) ? AFTER : BEFORE;
        this.addStepData(payload);
    }
    onHookEnd(payload) {
        if (this.options.disableHooks) {
            return;
        }
        payload.state = payload.error ? payload.state : PASSED;
        return this.updateStepStatus(payload);
    }
    onTestStart(payload) {
        this.addStepData(payload);
    }
    onTestPass(payload) {
        this.updateStepStatus(payload);
    }
    onTestFail(payload) {
        this.updateStepStatus(payload);
    }
    onTestSkip(payload) {
        this.updateStepStatus(payload);
    }
    onRunnerEnd() {
        if (!this.report.feature) {
            return;
        }
        const uniqueId = String(Date.now() + Math.random()).replace('.', '');
        const filename = this.options.reportFilePerRetry
            ? `${this.report.feature.id}_${uniqueId}.json`
            : `${this.report.feature.id}.json`;
        const jsonFolder = path.resolve(process.cwd(), this.options.jsonFolder);
        const jsonFile = path.resolve(jsonFolder, filename);
        const json = [this.report.feature];
        const output = fs.existsSync(jsonFile) ? json.concat(fs.readJsonSync(jsonFile)) : json;
        fs.outputJsonSync(jsonFile, output);
    }
    getFeatureDataObject(featureData) {
        const featureName = featureData.title;
        return {
            keyword: FEATURE,
            type: featureData.type,
            description: featureData.description || '',
            line: featureData.uid && featureData.uid.includes(':') ? parseInt(featureData.uid.split(':')[1], 10) : null,
            name: featureName,
            uri: featureData.file || 'Can not be determined',
            tags: featureData.tags || [],
            elements: [],
            id: featureName.replace(/[\\/?%*:|"<> ]/g, '-').toLowerCase(),
        };
    }
    getScenarioDataObject(scenarioData, id) {
        const scenarioName = scenarioData.title;
        return {
            keyword: SCENARIO,
            type: scenarioData.type,
            description: scenarioData.description || '',
            name: scenarioName,
            tags: scenarioData.tags || [],
            id: `${id}${scenarioData.title.replace(/ /g, '-').toLowerCase()}`,
            steps: [],
        };
    }
    getStepDataObject(stepData) {
        const keyword = stepData?.keyword || keywordStartsWith(stepData.title, this.options.language) || '';
        const title = (stepData.title.split(keyword).pop() || stepData.title || '').trim();
        return {
            arguments: stepData.argument ? [stepData.argument] : [],
            keyword,
            name: title,
            result: {
                status: stepData.state || '',
                duration: (stepData._duration || 0) * 1000000,
                ...getFailedMessage(stepData),
            },
            line: null,
            match: {
                location: 'can not be determined with webdriver.io',
            },
        };
    }
    getCurrentScenario() {
        return this.report.feature.elements[this.report.feature.elements.length - 1];
    }
    getCurrentStep() {
        const currentScenario = this.getCurrentScenario();
        return currentScenario.steps[currentScenario.steps.length - 1];
    }
    addStepData(test) {
        this.getCurrentScenario().steps.push(this.getStepDataObject(test));
    }
    updateStepStatus(test) {
        const currentSteps = this.getCurrentScenario().steps;
        const currentStepsLength = currentSteps.length;
        const stepData = this.getStepDataObject(test);
        currentSteps[currentStepsLength - 1] = { ...this.getCurrentStep(), ...stepData };
    }
    cucumberJsAttachment(attachment) {
        const currentStep = this.getCurrentStep();
        const embeddings = {
            data: attachment?.data,
            mime_type: attachment.type,
        };
        if (!currentStep.embeddings) {
            currentStep.embeddings = [embeddings];
        }
        else {
            currentStep.embeddings.push(embeddings);
        }
    }
}
export default CucumberJsJsonReporter;
//# sourceMappingURL=index.js.map